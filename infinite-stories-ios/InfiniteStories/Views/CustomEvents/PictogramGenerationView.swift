//
//  PictogramGenerationView.swift
//  InfiniteStories
//
//  View for generating and managing custom event pictograms
//

import SwiftUI
import SwiftData

struct PictogramGenerationView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext

    let event: CustomStoryEvent
    @StateObject private var generator = EventPictogramGenerator()
    @StateObject private var retryManager = PictogramRetryManager()

    @State private var selectedStyle: PictogramStyle = .playful
    @State private var customPrompt = ""
    @State private var useCustomPrompt = false
    @State private var isGenerating = false
    @State private var generatedImage: UIImage?
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var showSuccessAnimation = false

    private var autoGeneratedPrompt: String {
        let ageContext = "for children aged \(event.ageRange.minAge) to \(event.ageRange.maxAge)"
        return "A \(selectedStyle.stylePrompt) pictogram representing '\(event.title)'. \(event.eventDescription). Make it engaging \(ageContext) with a \(event.tone.rawValue.lowercased()) tone."
    }

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 24) {
                    // Current or Preview Section
                    currentPictogramSection

                    // Style Selection
                    styleSelectionSection

                    // Prompt Section
                    promptSection

                    // Generate Button
                    generateButton

                    // Status Section
                    if isGenerating {
                        generationStatusSection
                    }
                }
                .padding()
            }
            .navigationTitle("Pictogram Generator")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }

                ToolbarItem(placement: .navigationBarTrailing) {
                    if generatedImage != nil {
                        Button("Save") {
                            savePictogram()
                        }
                        .fontWeight(.semibold)
                    }
                }
            }
            .alert("Generation Error", isPresented: $showError) {
                Button("OK") { }
                Button("Retry") {
                    Task {
                        await generatePictogram()
                    }
                }
            } message: {
                Text(errorMessage)
            }
        }
        .onAppear {
            // Set initial style if event has one
            if let style = event.pictogramStyle {
                selectedStyle = style
            }
        }
    }

    // MARK: - Current Pictogram Section

    @ViewBuilder
    private var currentPictogramSection: some View {
        VStack(spacing: 16) {
            Text("Event Pictogram")
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)

            ZStack {
                RoundedRectangle(cornerRadius: 24)
                    .fill(
                        LinearGradient(
                            colors: [
                                Color(hex: event.colorHex).opacity(0.1),
                                Color(hex: event.colorHex).opacity(0.05)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(height: 200)

                if let generatedImage = generatedImage {
                    // Show newly generated image
                    Image(uiImage: generatedImage)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 160, height: 160)
                        .clipShape(RoundedRectangle(cornerRadius: 20))
                        .shadow(color: .black.opacity(0.1), radius: 5, y: 2)
                        .overlay(
                            RoundedRectangle(cornerRadius: 20)
                                .stroke(Color.green, lineWidth: 3)
                                .opacity(showSuccessAnimation ? 1 : 0)
                                .scaleEffect(showSuccessAnimation ? 1.1 : 1)
                                .animation(.easeInOut(duration: 0.5), value: showSuccessAnimation)
                        )
                } else if event.hasPictogram {
                    // Show existing pictogram
                    CachedPictogramImage(event: event)
                        .frame(width: 160, height: 160)
                        .clipShape(RoundedRectangle(cornerRadius: 20))
                        .shadow(color: .black.opacity(0.1), radius: 5, y: 2)
                } else {
                    // Show placeholder
                    VStack(spacing: 12) {
                        Image(systemName: event.iconName)
                            .font(.system(size: 60))
                            .foregroundColor(Color(hex: event.colorHex))

                        Text("No pictogram yet")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }

                // Loading overlay
                if isGenerating {
                    RoundedRectangle(cornerRadius: 24)
                        .fill(.ultraThinMaterial)
                        .overlay(
                            VStack(spacing: 12) {
                                ProgressView()
                                    .scaleEffect(1.5)
                                Text(generator.currentOperation)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        )
                }
            }

            // Event info
            VStack(spacing: 4) {
                Text(event.title)
                    .font(.title3)
                    .fontWeight(.semibold)

                Text(event.eventDescription)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .lineLimit(2)
            }
        }
    }

    // MARK: - Style Selection

    private var styleSelectionSection: some View {
        VStack(spacing: 12) {
            Text("Pictogram Style")
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)

            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 12) {
                ForEach(PictogramStyle.allCases, id: \.self) { style in
                    StyleCard(
                        style: style,
                        isSelected: selectedStyle == style,
                        action: {
                            withAnimation(.spring(duration: 0.3)) {
                                selectedStyle = style
                            }
                        }
                    )
                }
            }
        }
    }

    // MARK: - Prompt Section

    private var promptSection: some View {
        VStack(spacing: 12) {
            HStack {
                Text("Generation Prompt")
                    .font(.headline)

                Spacer()

                Toggle("Custom", isOn: $useCustomPrompt)
                    .toggleStyle(.button)
                    .buttonStyle(.bordered)
                    .controlSize(.small)
            }

            if useCustomPrompt {
                VStack(spacing: 8) {
                    TextEditor(text: $customPrompt)
                        .frame(minHeight: 100)
                        .padding(8)
                        .background(Color.gray.opacity(0.1))
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )

                    Text("Tip: Describe a simple, child-friendly icon that represents the event")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
            } else {
                Text(autoGeneratedPrompt)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(12)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(Color.gray.opacity(0.05))
                    .clipShape(RoundedRectangle(cornerRadius: 12))
            }
        }
    }

    // MARK: - Generate Button

    private var generateButton: some View {
        Button {
            Task {
                await generatePictogram()
            }
        } label: {
            HStack(spacing: 8) {
                Image(systemName: "wand.and.stars")
                Text(event.hasPictogram ? "Regenerate Pictogram" : "Generate Pictogram")
            }
            .font(.headline)
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                LinearGradient(
                    colors: [.purple, .blue],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .clipShape(RoundedRectangle(cornerRadius: 16))
            .shadow(color: .purple.opacity(0.3), radius: 8, y: 4)
        }
        .disabled(isGenerating || (useCustomPrompt && customPrompt.isEmpty))
        .opacity((isGenerating || (useCustomPrompt && customPrompt.isEmpty)) ? 0.6 : 1)
    }

    // MARK: - Generation Status

    private var generationStatusSection: some View {
        VStack(spacing: 12) {
            ProgressView(value: generator.generationProgress) {
                Text("Generating Pictogram...")
                    .font(.headline)
            }
            .progressViewStyle(.linear)
            .tint(.purple)

            HStack(spacing: 8) {
                Image(systemName: "info.circle")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Text(generator.currentOperation)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }

    // MARK: - Methods

    private func generatePictogram() async {
        isGenerating = true
        showSuccessAnimation = false

        do {
            // Prepare the prompt
            let prompt = useCustomPrompt && !customPrompt.isEmpty
                ? customPrompt
                : autoGeneratedPrompt

            // Update event with custom prompt if used
            if useCustomPrompt && !customPrompt.isEmpty {
                event.promptSeed = prompt
            }

            // Generate with retry manager
            let url = try await retryManager.generateWithRetry(
                event: event,
                generator: generator,
                style: selectedStyle
            )

            // Load the generated image
            if let image = UIImage(contentsOfFile: url.path) {
                await MainActor.run {
                    self.generatedImage = image
                    self.showSuccessAnimation = true
                    self.isGenerating = false

                    // Animate success
                    withAnimation(.easeInOut(duration: 0.5)) {
                        showSuccessAnimation = true
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                        showSuccessAnimation = false
                    }
                }
            }

        } catch {
            await MainActor.run {
                self.errorMessage = error.localizedDescription
                self.showError = true
                self.isGenerating = false
            }
        }
    }

    private func savePictogram() {
        // The pictogram is already saved by the generator
        // Just update the cache and dismiss
        if let image = generatedImage {
            PictogramCacheManager.shared.store(image, for: event.id)
        }
        dismiss()
    }
}

// MARK: - Style Card

struct StyleCard: View {
    let style: PictogramStyle
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                ZStack {
                    RoundedRectangle(cornerRadius: 12)
                        .fill(isSelected ? Color.purple.opacity(0.2) : Color.gray.opacity(0.1))
                        .frame(height: 60)

                    Image(systemName: style.icon)
                        .font(.title2)
                        .foregroundColor(isSelected ? .purple : .secondary)
                }

                Text(style.displayName)
                    .font(.caption)
                    .fontWeight(isSelected ? .semibold : .regular)
                    .foregroundColor(isSelected ? .purple : .primary)
            }
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(isSelected ? Color.purple : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    NavigationStack {
        PictogramGenerationView(
            event: CustomStoryEvent(
                title: "First Day at School",
                description: "A story about overcoming nervousness and making new friends",
                promptSeed: "Starting school adventure",
                category: .learning,
                ageRange: .preschool,
                tone: .inspiring
            )
        )
    }
    .modelContainer(for: [CustomStoryEvent.self], inMemory: true)
}