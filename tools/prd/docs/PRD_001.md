# PRD-001: Complete Supabase to Firebase Migration

**Document Version**: 1.0
**Created**: 2025-10-03
**Status**: Planning
**Priority**: Critical
**Estimated Duration**: 6 weeks
**Owner**: TBD

---

## Executive Summary

This PRD outlines the complete migration of InfiniteStories iOS application from Supabase backend to Firebase backend. The migration will remove all Supabase dependencies while maintaining 100% feature parity. After completion, the app will operate exclusively on Firebase infrastructure.

### Goals
1. **Complete Supabase Removal**: Eliminate all Supabase SDK dependencies and code
2. **Feature Parity**: Maintain all existing functionality without regression
3. **Zero Data Loss**: Migrate all user data safely
4. **Zero Downtime**: Seamless transition for active users
5. **Cost Optimization**: Reduce backend costs through Firebase pricing advantages
6. **Enhanced Developer Experience**: Leverage Firebase's superior iOS SDK integration

### Non-Goals
- Adding new features during migration
- Changing UI/UX
- Modifying business logic
- Changing AI model providers

---

## Background

### Current State
- **Primary Backend**: Supabase (PostgreSQL, Edge Functions, Storage, Auth)
- **iOS Integration**: supabase-swift v2.33.1
- **Deployment**: Local development + production Supabase instance
- **Feature Flag**: Partial Firebase implementation exists but not activated

### Problem Statement
1. Supabase integration adds complexity and dependencies
2. Dual backend maintenance overhead
3. Firebase infrastructure already deployed but unused
4. Opportunity to consolidate on single, well-integrated platform

### Success Criteria
- [ ] 0 Supabase imports in codebase
- [ ] All tests passing with Firebase backend
- [ ] All user data migrated successfully
- [ ] No feature regressions
- [ ] Production deployment successful
- [ ] Supabase services decommissioned

---

## Detailed Supabase Usage Inventory

### 1. Authentication

#### Current Implementation
**File**: `InfiniteStories/Services/SupabaseService.swift:52-80`

```swift
// Current state: Development mode using hardcoded user ID
private var userId: UUID {
    #if DEBUG
    UUID(uuidString: "00000000-0000-0000-0000-000000000001")!
    #else
    // Production would use Supabase Auth
    client.auth.session?.user.id ?? UUID()
    #endif
}
```

**Migration Required**:
- Replace with Firebase Authentication
- Implement user session management
- Handle authentication state changes
- Migrate existing user accounts (if any)

**Firebase Equivalent**:
- `FirebaseAuth` SDK
- Code already exists in `Services/Firebase-Pending/FirebaseAuthService.swift`

---

### 2. Database Operations

#### Tables and Operations

##### 2.1 Heroes Table
**File**: `SupabaseService.swift:101-175`

**Operations**:
```swift
// Upsert hero
func saveHero(_ hero: Hero) async throws
// Query: FROM heroes WHERE user_id = $1 ORDER BY created_at DESC
func fetchHeroes() async throws -> [Hero]
// Delete: WHERE id = $1 AND user_id = $2
func deleteHero(_ hero: Hero) async throws
```

**Firestore Equivalent**:
```
Collection: heroes
Document ID: {heroId}
Structure: {
  userId: string,
  name: string,
  primaryTrait: string,
  secondaryTrait: string,
  appearance: string,
  specialAbility: string,
  avatarUrl: string,
  avatarPrompt: string,
  avatarGenerationId: string,
  createdAt: timestamp,
  updatedAt: timestamp
}

Subcollection: heroes/{heroId}/visualProfiles
```

**Security Rules**:
```javascript
match /heroes/{heroId} {
  allow read, write: if request.auth.uid == resource.data.userId;
  allow create: if request.auth.uid == request.resource.data.userId;
}
```

##### 2.2 Stories Table
**File**: `SupabaseService.swift:177-262`

**Operations**:
```swift
// Upsert story
func saveStory(_ story: Story) async throws
// Query: FROM stories WHERE user_id = $1 ORDER BY created_at DESC
func fetchStories() async throws -> [Story]
// Query: WHERE hero_id = $1 AND user_id = $2
func fetchStoriesForHero(_ heroId: UUID) async throws -> [Story]
```

**Firestore Equivalent**:
```
Collection: stories
Document ID: {storyId}
Structure: {
  userId: string,
  heroId: reference,
  title: string,
  content: string,
  eventType: string,
  eventData: map,
  audioUrl: string,
  duration: number,
  language: string,
  sceneCount: number,
  createdAt: timestamp
}

Subcollection: stories/{storyId}/illustrations
```

**Composite Indexes Required**:
- `userId + createdAt` (descending)
- `heroId + createdAt` (descending)

##### 2.3 Custom Events Table
**Referenced but not directly accessed in current code**

**Firestore Equivalent**:
```
Collection: customEvents
Document ID: {eventId}
Structure: {
  userId: string,
  title: string,
  description: string,
  promptSeed: string,
  tone: string,
  ageRange: string,
  category: string,
  keywords: array<string>,
  pictogram: string,
  usageCount: number,
  isFavorite: boolean,
  createdAt: timestamp
}
```

##### 2.4 Supporting Tables (for future implementation)
- `api_usage` → Firestore collection for analytics
- `rate_limits` → Use Firebase App Check + Cloud Functions rate limiting
- `api_cache` → Use Firestore TTL or Cloud Functions caching
- `generation_queue` → Use Cloud Tasks or Pub/Sub

---

### 3. Storage Operations

#### 3.1 Hero Avatars Bucket
**File**: `SupabaseService.swift:677-761`

**Operations**:
```swift
func uploadAvatar(heroId: UUID, imageData: Data) async throws -> String
func downloadAvatar(url: String) async throws -> Data
func deleteAvatar(heroId: UUID) async throws
func getPublicURL(bucket: String, path: String) -> String
```

**Path Format**: `{userId}/{heroId}/avatar.png`

**Firebase Storage Equivalent**:
```
Bucket: infinite-stories-5a980.firebasestorage.app
Path: hero-avatars/{userId}/{heroId}/avatar.png

Security Rules:
match /hero-avatars/{userId}/{heroId}/{fileName} {
  allow read: if true; // Public read
  allow write: if request.auth.uid == userId;
  allow delete: if request.auth.uid == userId;
}
```

#### 3.2 Story Audio Bucket
**File**: `SupabaseService.swift:764-853`

**Operations**:
```swift
func uploadStoryAudio(storyId: UUID, audioData: Data) async throws -> String
func downloadStoryAudio(url: String) async throws -> Data
func deleteStoryAudio(storyId: UUID) async throws
```

**Path Format**: `{userId}/{storyId}/audio.mp3`

**Firebase Storage Equivalent**:
```
Path: story-audio/{userId}/{storyId}/audio.mp3

Security Rules:
match /story-audio/{userId}/{storyId}/{fileName} {
  allow read: if request.auth.uid == userId || true; // Public read for sharing
  allow write, delete: if request.auth.uid == userId;
}
```

#### 3.3 Story Illustrations Bucket
**File**: `SupabaseService.swift:856-952`

**Operations**:
```swift
func uploadSceneIllustration(storyId: UUID, sceneNumber: Int, imageData: Data) async throws -> String
func downloadSceneIllustration(url: String) async throws -> Data
func deleteSceneIllustration(storyId: UUID, sceneNumber: Int) async throws
```

**Path Format**: `{userId}/{storyId}/scene_{number}.png`

**Firebase Storage Equivalent**:
```
Path: story-illustrations/{userId}/{storyId}/scene_{number}.png

Security Rules:
match /story-illustrations/{userId}/{storyId}/{fileName} {
  allow read: if request.auth.uid == userId || true;
  allow write, delete: if request.auth.uid == userId;
}
```

---

### 4. Edge Functions → Cloud Functions

All Edge Functions must be migrated to Cloud Functions. Backend code already exists in `backend/functions/`.

#### 4.1 Story Generation
**Current**: `SupabaseService.swift:265-338`
**Backend**: `backend/functions/story-generation.ts` ✅

**Request**:
```typescript
{
  hero_id: string,
  event: {
    type: "built_in" | "custom",
    data: { name: string } | CustomEvent
  },
  target_duration: number,
  language: string
}
```

**Response**:
```typescript
{
  story: {
    title: string,
    content: string,
    scenes: Array<{
      number: number,
      content: string,
      visualization_prompt: string
    }>
  }
}
```

**Migration Notes**:
- Function already implemented in Firebase
- Update iOS client to call Firebase endpoint
- Ensure content safety filters active

#### 4.2 Audio Synthesis
**Current**: `SupabaseService.swift:340-414`
**Backend**: `backend/functions/audio-synthesis.ts` ✅

**Request**:
```typescript
{
  text: string,
  language: string,
  voice?: string,
  speed?: number
}
```

**Response**:
```typescript
{
  audio_url: string,
  duration: number
}
```

#### 4.3 Avatar Generation
**Current**: `SupabaseService.swift:470-546`
**Backend**: `backend/functions/avatar-generation.ts` ✅

**Request**:
```typescript
{
  hero_id: string,
  prompt: string,
  style: string,
  quality: string,
  size: string
}
```

**Response**:
```typescript
{
  image_url: string,
  generation_id: string,
  revised_prompt: string
}
```

#### 4.4 Scene Illustration
**Current**: `SupabaseService.swift:548-654`
**Backend**: `backend/functions/scene-illustration.ts` ✅

**Request**:
```typescript
{
  story_id: string,
  scene_number: number,
  prompt: string,
  hero_generation_id?: string,
  style: string
}
```

**Response**:
```typescript
{
  image_url: string,
  generation_id: string
}
```

#### 4.5 Extract Scenes
**Current**: `SupabaseService.swift:416-468`
**Backend**: `backend/functions/extract-scenes.ts` ✅

**Request**:
```typescript
{
  story_content: string,
  target_scene_count: number
}
```

**Response**:
```typescript
{
  scenes: Array<{
    number: number,
    content: string,
    visualization_prompt: string
  }>
}
```

---

### 5. Real-time Subscriptions

**Current Status**: Not implemented (placeholder methods exist)
**File**: `SupabaseService.swift:657-666`

**Future Firebase Implementation**:
```swift
// Firestore real-time listeners
func observeHeroes() -> AsyncThrowingStream<[Hero], Error> {
    AsyncThrowingStream { continuation in
        let listener = db.collection("heroes")
            .whereField("userId", isEqualTo: userId)
            .addSnapshotListener { snapshot, error in
                // Handle updates
            }
        continuation.onTermination = { _ in
            listener.remove()
        }
    }
}
```

**Migration Notes**:
- Lower priority (not currently used)
- Implement if/when needed
- Firebase offers superior real-time capabilities

---

### 6. Dependencies to Remove

#### Swift Package Dependencies
**File**: `InfiniteStories.xcodeproj/project.pbxproj`

**Remove**:
- `supabase-swift` (v2.33.1)
- `postgrest-swift` (dependency)
- `realtime-swift` (dependency)
- `storage-swift` (dependency)
- `functions-swift` (dependency)
- `gotrue-swift` (dependency)

**Retain**:
- All Firebase packages (already installed)

#### Source Files to Remove
```
InfiniteStories/Services/SupabaseService.swift
InfiniteStories/Services/SupabaseAIService.swift
InfiniteStories/Services/SupabaseConfig.swift
InfiniteStories/Services/SupabaseHelpers.swift
```

#### Source Files to Activate
```
InfiniteStories/Services/Firebase-Pending/FirebaseAuthService.swift → Services/
InfiniteStories/Services/Firebase-Pending/FirebaseAuthView.swift → Views/Auth/
InfiniteStories/Services/Firebase-Pending/AuthMigrationHelper.swift → Services/
```

---

## Migration Architecture

### Target Architecture

```
┌─────────────────────────────────────────────────────────┐
│                 InfiniteStories iOS App                  │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │              ViewModels (MVVM)                 │    │
│  │  - HeroViewModel                              │    │
│  │  - StoryViewModel                             │    │
│  │  - AuthViewModel                              │    │
│  └────────────────────────────────────────────────┘    │
│                        │                                │
│                        ▼                                │
│  ┌────────────────────────────────────────────────┐    │
│  │           Service Layer (Protocols)            │    │
│  │  - AIServiceProtocol                          │    │
│  │  - DataServiceProtocol                        │    │
│  │  - AuthServiceProtocol                        │    │
│  │  - StorageServiceProtocol                     │    │
│  └────────────────────────────────────────────────┘    │
│                        │                                │
│                        ▼                                │
│  ┌────────────────────────────────────────────────┐    │
│  │         Firebase Service Implementation        │    │
│  │  - FirebaseAIService ✅                        │    │
│  │  - FirebaseDataService (NEW)                  │    │
│  │  - FirebaseAuthService ✅ (pending)            │    │
│  │  - FirebaseStorageService (NEW)               │    │
│  └────────────────────────────────────────────────┘    │
│                        │                                │
│                        ▼                                │
│  ┌────────────────────────────────────────────────┐    │
│  │              Firebase iOS SDK                  │    │
│  │  - Auth                                       │    │
│  │  - Firestore                                  │    │
│  │  - Storage                                    │    │
│  │  - Functions                                  │    │
│  └────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
                            │
                            │ HTTPS
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   Firebase Backend                       │
│                (infinite-stories-5a980)                  │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │         Firebase Authentication                │    │
│  │  - Email/Password provider                    │    │
│  │  - Anonymous auth (for demos)                 │    │
│  │  - Custom claims for authorization            │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │           Cloud Firestore (eur3)               │    │
│  │  Collections:                                  │    │
│  │  ├─ users/{userId}                            │    │
│  │  ├─ heroes/{heroId}                           │    │
│  │  │   └─ visualProfiles/{profileId}            │    │
│  │  ├─ stories/{storyId}                         │    │
│  │  │   └─ illustrations/{illustrationId}        │    │
│  │  └─ customEvents/{eventId}                    │    │
│  │                                                │    │
│  │  Indexes:                                      │    │
│  │  - heroes: userId + createdAt (desc)          │    │
│  │  - stories: userId + createdAt (desc)         │    │
│  │  - stories: heroId + createdAt (desc)         │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │         Cloud Functions (2nd gen)              │    │
│  │  Functions:                                    │    │
│  │  ├─ storyGeneration (GPT-5)           ✅      │    │
│  │  ├─ audioSynthesis (gpt-4o-mini-tts)  ✅      │    │
│  │  ├─ avatarGeneration (GPT-5)          ✅      │    │
│  │  ├─ sceneIllustration (GPT-5)         ✅      │    │
│  │  ├─ extractScenes (GPT-5)             ✅      │    │
│  │  └─ contentSafety (filtering)         ✅      │    │
│  │                                                │    │
│  │  Runtime: Node.js 20                          │    │
│  │  Region: eur3                                 │    │
│  │  Secrets: OPENAI_API_KEY ✅                   │    │
│  └────────────────────────────────────────────────┘    │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │           Firebase Storage                     │    │
│  │  Buckets:                                      │    │
│  │  ├─ hero-avatars/                             │    │
│  │  │   └─ {userId}/{heroId}/avatar.png          │    │
│  │  ├─ story-audio/                              │    │
│  │  │   └─ {userId}/{storyId}/audio.mp3          │    │
│  │  └─ story-illustrations/                      │    │
│  │      └─ {userId}/{storyId}/scene_N.png        │    │
│  └────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

---

## Migration Phases

### Phase 1: Foundation & Setup (Week 1)

#### 1.1 Create New Service Protocols
**Location**: `InfiniteStories/Services/Protocols/`

**Files to Create**:
```swift
// DataServiceProtocol.swift
protocol DataServiceProtocol {
    func saveHero(_ hero: Hero) async throws
    func fetchHeroes() async throws -> [Hero]
    func deleteHero(_ hero: Hero) async throws

    func saveStory(_ story: Story) async throws
    func fetchStories() async throws -> [Story]
    func fetchStoriesForHero(_ heroId: UUID) async throws -> [Story]

    func saveCustomEvent(_ event: CustomStoryEvent) async throws
    func fetchCustomEvents() async throws -> [CustomStoryEvent]
    func deleteCustomEvent(_ event: CustomStoryEvent) async throws
}

// StorageServiceProtocol.swift
protocol StorageServiceProtocol {
    func uploadAvatar(heroId: UUID, imageData: Data) async throws -> String
    func downloadAvatar(url: String) async throws -> Data
    func deleteAvatar(heroId: UUID) async throws

    func uploadStoryAudio(storyId: UUID, audioData: Data) async throws -> String
    func downloadStoryAudio(url: String) async throws -> Data
    func deleteStoryAudio(storyId: UUID) async throws

    func uploadSceneIllustration(storyId: UUID, sceneNumber: Int, imageData: Data) async throws -> String
    func downloadSceneIllustration(url: String) async throws -> Data
    func deleteSceneIllustration(storyId: UUID, sceneNumber: Int) async throws
}

// AuthServiceProtocol.swift (already exists in Firebase-Pending)
protocol AuthServiceProtocol {
    var currentUser: User? { get }
    var isAuthenticated: Bool { get }

    func signUp(email: String, password: String) async throws -> User
    func signIn(email: String, password: String) async throws -> User
    func signOut() throws
    func deleteAccount() async throws
}
```

#### 1.2 Update Firebase Configuration
**File**: `InfiniteStories/Services/FirebaseConfig.swift`

**Required Updates**:
- Remove placeholder comments
- Add production configuration
- Implement environment detection
- Add service getters for Firestore, Storage, Auth

#### 1.3 Firestore Setup

**Backend Tasks** (`backend/firestore.rules`):
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(request.resource.data.uid);
      allow update, delete: if isOwner(userId);
    }

    // Heroes collection
    match /heroes/{heroId} {
      allow read: if isOwner(resource.data.userId);
      allow create: if isOwner(request.resource.data.userId);
      allow update, delete: if isOwner(resource.data.userId);

      // Visual profiles subcollection
      match /visualProfiles/{profileId} {
        allow read, write: if isOwner(get(/databases/$(database)/documents/heroes/$(heroId)).data.userId);
      }
    }

    // Stories collection
    match /stories/{storyId} {
      allow read: if isOwner(resource.data.userId);
      allow create: if isOwner(request.resource.data.userId);
      allow update, delete: if isOwner(resource.data.userId);

      // Illustrations subcollection
      match /illustrations/{illustrationId} {
        allow read, write: if isOwner(get(/databases/$(database)/documents/stories/$(storyId)).data.userId);
      }
    }

    // Custom events collection
    match /customEvents/{eventId} {
      allow read: if isOwner(resource.data.userId);
      allow create: if isOwner(request.resource.data.userId);
      allow update, delete: if isOwner(resource.data.userId);
    }
  }
}
```

**Composite Indexes** (`backend/firestore.indexes.json`):
```json
{
  "indexes": [
    {
      "collectionGroup": "heroes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "stories",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "stories",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "heroId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "customEvents",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "isFavorite", "order": "DESCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    }
  ]
}
```

#### 1.4 Firebase Storage Setup

**Backend Tasks** (`backend/storage.rules`):
```javascript
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isImage() {
      return request.resource.contentType.matches('image/.*');
    }

    function isAudio() {
      return request.resource.contentType.matches('audio/.*');
    }

    function isValidSize(maxSizeMB) {
      return request.resource.size < maxSizeMB * 1024 * 1024;
    }

    // Hero avatars bucket
    match /hero-avatars/{userId}/{heroId}/{fileName} {
      allow read: if true; // Public read for sharing
      allow write: if isAuthenticated()
                   && isOwner(userId)
                   && isImage()
                   && isValidSize(10);
      allow delete: if isAuthenticated() && isOwner(userId);
    }

    // Story audio bucket
    match /story-audio/{userId}/{storyId}/{fileName} {
      allow read: if true; // Public read for sharing
      allow write: if isAuthenticated()
                   && isOwner(userId)
                   && isAudio()
                   && isValidSize(50);
      allow delete: if isAuthenticated() && isOwner(userId);
    }

    // Story illustrations bucket
    match /story-illustrations/{userId}/{storyId}/{fileName} {
      allow read: if true; // Public read for sharing
      allow write: if isAuthenticated()
                   && isOwner(userId)
                   && isImage()
                   && isValidSize(10);
      allow delete: if isAuthenticated() && isOwner(userId);
    }
  }
}
```

#### 1.5 Verify Backend Deployment

**Verification Checklist**:
- [ ] All Cloud Functions deployed and callable
- [ ] Firestore security rules deployed
- [ ] Storage security rules deployed
- [ ] Composite indexes created
- [ ] OpenAI API key configured in secrets
- [ ] Environment variables set correctly

**Commands**:
```bash
cd backend
firebase deploy --only firestore:rules
firebase deploy --only firestore:indexes
firebase deploy --only storage
firebase deploy --only functions
firebase functions:secrets:verify OPENAI_API_KEY
```

---

### Phase 2: Implement Firebase Services (Week 2)

#### 2.1 FirebaseDataService Implementation

**File**: `InfiniteStories/Services/FirebaseDataService.swift`

**Key Implementation Details**:

```swift
import Foundation
import FirebaseFirestore
import FirebaseAuth

class FirebaseDataService: DataServiceProtocol {
    private let db = Firestore.firestore()

    private var userId: String {
        guard let uid = Auth.auth().currentUser?.uid else {
            fatalError("User not authenticated")
        }
        return uid
    }

    // MARK: - Hero Operations

    func saveHero(_ hero: Hero) async throws {
        let docRef = db.collection("heroes").document(hero.id.uuidString)
        let data: [String: Any] = [
            "userId": userId,
            "name": hero.name,
            "primaryTrait": hero.primaryTrait,
            "secondaryTrait": hero.secondaryTrait,
            "age": hero.age,
            "appearance": hero.appearance,
            "specialAbility": hero.specialAbility,
            "avatarPrompt": hero.avatarPrompt ?? "",
            "avatarUrl": hero.avatarUrl ?? "",
            "avatarGenerationId": hero.avatarGenerationId ?? "",
            "createdAt": hero.createdAt,
            "updatedAt": Timestamp(date: Date())
        ]
        try await docRef.setData(data, merge: true)
    }

    func fetchHeroes() async throws -> [Hero] {
        let snapshot = try await db.collection("heroes")
            .whereField("userId", isEqualTo: userId)
            .order(by: "createdAt", descending: true)
            .getDocuments()

        return try snapshot.documents.compactMap { doc in
            try doc.data(as: Hero.self)
        }
    }

    func deleteHero(_ hero: Hero) async throws {
        try await db.collection("heroes")
            .document(hero.id.uuidString)
            .delete()
    }

    // MARK: - Story Operations

    func saveStory(_ story: Story) async throws {
        let docRef = db.collection("stories").document(story.id.uuidString)
        // Map Story to Firestore document
        // Handle nested event data
        // Handle references to heroes
        try await docRef.setData(story.toFirestoreData(), merge: true)
    }

    func fetchStories() async throws -> [Story] {
        let snapshot = try await db.collection("stories")
            .whereField("userId", isEqualTo: userId)
            .order(by: "createdAt", descending: true)
            .getDocuments()

        return try snapshot.documents.compactMap { doc in
            try doc.data(as: Story.self)
        }
    }

    func fetchStoriesForHero(_ heroId: UUID) async throws -> [Story] {
        let heroRef = db.collection("heroes").document(heroId.uuidString)
        let snapshot = try await db.collection("stories")
            .whereField("heroId", isEqualTo: heroRef)
            .order(by: "createdAt", descending: true)
            .getDocuments()

        return try snapshot.documents.compactMap { doc in
            try doc.data(as: Story.self)
        }
    }

    // MARK: - Custom Events (future)

    func saveCustomEvent(_ event: CustomStoryEvent) async throws {
        // Implementation
    }

    func fetchCustomEvents() async throws -> [CustomStoryEvent] {
        // Implementation
    }

    func deleteCustomEvent(_ event: CustomStoryEvent) async throws {
        // Implementation
    }
}
```

**Model Updates Required**:
- Add `Codable` conformance optimized for Firestore
- Add `toFirestoreData()` and `fromFirestoreData()` helpers
- Handle UUID ↔ String conversions
- Handle Date ↔ Timestamp conversions
- Handle nested objects and references

#### 2.2 FirebaseStorageService Implementation

**File**: `InfiniteStories/Services/FirebaseStorageService.swift`

**Key Implementation Details**:

```swift
import Foundation
import FirebaseStorage
import FirebaseAuth

class FirebaseStorageService: StorageServiceProtocol {
    private let storage = Storage.storage()

    private var userId: String {
        guard let uid = Auth.auth().currentUser?.uid else {
            fatalError("User not authenticated")
        }
        return uid
    }

    // MARK: - Avatar Operations

    func uploadAvatar(heroId: UUID, imageData: Data) async throws -> String {
        let path = "hero-avatars/\(userId)/\(heroId.uuidString)/avatar.png"
        let storageRef = storage.reference().child(path)

        let metadata = StorageMetadata()
        metadata.contentType = "image/png"

        _ = try await storageRef.putDataAsync(imageData, metadata: metadata)
        let downloadURL = try await storageRef.downloadURL()

        return downloadURL.absoluteString
    }

    func downloadAvatar(url: String) async throws -> Data {
        guard let storageUrl = URL(string: url) else {
            throw StorageError.invalidURL
        }

        let storageRef = storage.reference(forURL: storageUrl.absoluteString)
        let maxSize: Int64 = 10 * 1024 * 1024 // 10MB
        return try await storageRef.data(maxSize: maxSize)
    }

    func deleteAvatar(heroId: UUID) async throws {
        let path = "hero-avatars/\(userId)/\(heroId.uuidString)/avatar.png"
        let storageRef = storage.reference().child(path)
        try await storageRef.delete()
    }

    // MARK: - Audio Operations

    func uploadStoryAudio(storyId: UUID, audioData: Data) async throws -> String {
        let path = "story-audio/\(userId)/\(storyId.uuidString)/audio.mp3"
        let storageRef = storage.reference().child(path)

        let metadata = StorageMetadata()
        metadata.contentType = "audio/mpeg"

        _ = try await storageRef.putDataAsync(imageData, metadata: metadata)
        let downloadURL = try await storageRef.downloadURL()

        return downloadURL.absoluteString
    }

    func downloadStoryAudio(url: String) async throws -> Data {
        // Similar to downloadAvatar but with larger size limit
    }

    func deleteStoryAudio(storyId: UUID) async throws {
        // Similar to deleteAvatar
    }

    // MARK: - Illustration Operations

    func uploadSceneIllustration(storyId: UUID, sceneNumber: Int, imageData: Data) async throws -> String {
        let path = "story-illustrations/\(userId)/\(storyId.uuidString)/scene_\(sceneNumber).png"
        // Similar to uploadAvatar
    }

    func downloadSceneIllustration(url: String) async throws -> Data {
        // Similar to downloadAvatar
    }

    func deleteSceneIllustration(storyId: UUID, sceneNumber: Int) async throws {
        // Similar to deleteAvatar
    }
}

enum StorageError: Error {
    case invalidURL
    case uploadFailed
    case downloadFailed
    case deleteFailed
}
```

#### 2.3 Activate FirebaseAuthService

**Source**: Move from `Services/Firebase-Pending/FirebaseAuthService.swift`
**Destination**: `Services/FirebaseAuthService.swift`

**Integration Steps**:
1. Move FirebaseAuthService.swift to Services/
2. Update AuthViewModel to use FirebaseAuthService
3. Implement authentication state observer
4. Handle authentication errors
5. Update UI to show authentication views when needed

#### 2.4 Update AIServiceFactory

**File**: `InfiniteStories/Services/AIServiceFactory.swift`

**Changes**:
```swift
class AIServiceFactory {
    static var shared: AIServiceProtocol {
        // Remove feature flag - always use Firebase
        FirebaseAIService()
    }

    static var dataService: DataServiceProtocol {
        FirebaseDataService()
    }

    static var storageService: StorageServiceProtocol {
        FirebaseStorageService()
    }

    static var authService: AuthServiceProtocol {
        FirebaseAuthService()
    }
}
```

---

### Phase 3: Model Updates & Data Migration (Week 3)

#### 3.1 Update Model Codable Implementations

**Files to Update**:
- `InfiniteStories/Models/Hero.swift`
- `InfiniteStories/Models/Story.swift`
- `InfiniteStories/Models/CustomStoryEvent.swift`
- `InfiniteStories/Models/StoryIllustration.swift`

**Required Changes**:

```swift
// Hero.swift
extension Hero: Codable {
    enum CodingKeys: String, CodingKey {
        case id, userId, name, primaryTrait, secondaryTrait
        case age, appearance, specialAbility
        case avatarPrompt, avatarUrl, avatarGenerationId
        case createdAt, updatedAt
    }

    // Custom Firestore encoding
    func toFirestoreData() -> [String: Any] {
        [
            "id": id.uuidString,
            "userId": userId,
            "name": name,
            "primaryTrait": primaryTrait,
            "secondaryTrait": secondaryTrait,
            "age": age,
            "appearance": appearance,
            "specialAbility": specialAbility,
            "avatarPrompt": avatarPrompt ?? "",
            "avatarUrl": avatarUrl ?? "",
            "avatarGenerationId": avatarGenerationId ?? "",
            "createdAt": Timestamp(date: createdAt),
            "updatedAt": Timestamp(date: updatedAt)
        ]
    }

    // Custom Firestore decoding
    init(from firestoreData: [String: Any]) throws {
        guard let idString = firestoreData["id"] as? String,
              let id = UUID(uuidString: idString),
              let userId = firestoreData["userId"] as? String,
              let name = firestoreData["name"] as? String,
              // ... etc
        else {
            throw DecodingError.dataCorrupted(...)
        }

        self.id = id
        self.userId = userId
        self.name = name
        // ... etc
    }
}

// Similar updates for Story, CustomStoryEvent, etc.
```

**Key Considerations**:
- UUID ↔ String conversions
- Date ↔ Timestamp conversions
- Optional field handling
- Nested object encoding
- Reference field handling (heroId in Story)

#### 3.2 Create Data Migration Script (if production data exists)

**File**: `backend/scripts/migrate-data.ts`

**Purpose**: One-time migration of production data from Supabase to Firebase

**Implementation**:
```typescript
import { createClient } from '@supabase/supabase-js';
import { initializeApp } from 'firebase-admin/app';
import { getFirestore, Timestamp } from 'firebase-admin/firestore';
import { getStorage } from 'firebase-admin/storage';

// Initialize both services
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
initializeApp();
const db = getFirestore();
const storage = getStorage();

async function migrateHeroes() {
  console.log('Migrating heroes...');
  const { data, error } = await supabase.from('heroes').select('*');

  if (error) throw error;

  for (const hero of data) {
    await db.collection('heroes').doc(hero.id).set({
      userId: hero.user_id,
      name: hero.name,
      primaryTrait: hero.primary_trait,
      secondaryTrait: hero.secondary_trait,
      age: hero.age,
      appearance: hero.appearance,
      specialAbility: hero.special_ability,
      avatarPrompt: hero.avatar_prompt || '',
      avatarUrl: hero.avatar_url || '',
      avatarGenerationId: hero.avatar_generation_id || '',
      createdAt: Timestamp.fromDate(new Date(hero.created_at)),
      updatedAt: Timestamp.now()
    });
  }

  console.log(`Migrated ${data.length} heroes`);
}

async function migrateStories() {
  // Similar implementation
}

async function migrateStorage() {
  console.log('Migrating storage files...');

  // Download from Supabase Storage, upload to Firebase Storage
  // Buckets: hero-avatars, story-audio, story-illustrations
}

async function main() {
  try {
    await migrateHeroes();
    await migrateStories();
    await migrateStorage();
    console.log('Migration complete!');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}

main();
```

**Usage**:
```bash
cd backend
npm install @supabase/supabase-js
export SUPABASE_URL=https://your-project.supabase.co
export SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
npx ts-node scripts/migrate-data.ts
```

**Validation**:
- Compare record counts between Supabase and Firestore
- Verify sample records for data integrity
- Check storage file accessibility
- Validate user authentication mapping

---

### Phase 4: iOS App Integration (Week 4)

#### 4.1 Update ViewModels

**Files to Update**:
- `InfiniteStories/ViewModels/HeroViewModel.swift`
- `InfiniteStories/ViewModels/StoryViewModel.swift`
- Any other ViewModels using SupabaseService

**Changes**:
```swift
// Before (Supabase)
private let supabaseService = SupabaseService.shared

func loadHeroes() async {
    do {
        heroes = try await supabaseService.fetchHeroes()
    } catch {
        // Handle error
    }
}

// After (Firebase)
private let dataService = AIServiceFactory.dataService

func loadHeroes() async {
    do {
        heroes = try await dataService.fetchHeroes()
    } catch {
        // Handle error
    }
}
```

#### 4.2 Update Views

**Files to Update**:
- Any view importing `Supabase`
- Any view directly using SupabaseService

**Search for**:
```bash
grep -r "import Supabase" InfiniteStories/
grep -r "SupabaseService" InfiniteStories/
```

**Replace**:
- Remove `import Supabase` statements
- Replace SupabaseService references with appropriate Firebase services

#### 4.3 Update App Initialization

**File**: `InfiniteStories/InfiniteStoriesApp.swift`

**Current**:
```swift
import SwiftUI
import Firebase

@main
struct InfiniteStoriesApp: App {
    init() {
        FirebaseApp.configure()
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

**Updated**:
```swift
import SwiftUI
import Firebase
import FirebaseAuth

@main
struct InfiniteStoriesApp: App {
    @StateObject private var authViewModel = AuthViewModel()

    init() {
        FirebaseApp.configure()

        // Configure Firestore settings
        let settings = FirestoreSettings()
        settings.isPersistenceEnabled = true
        settings.cacheSizeBytes = FirestoreCacheSizeUnlimited
        Firestore.firestore().settings = settings
    }

    var body: some Scene {
        WindowGroup {
            if authViewModel.isAuthenticated {
                ContentView()
                    .environmentObject(authViewModel)
            } else {
                FirebaseAuthView()
                    .environmentObject(authViewModel)
            }
        }
    }
}
```

#### 4.4 Remove Supabase Dependencies

**File**: `InfiniteStories.xcodeproj/project.pbxproj`

**Steps**:
1. Open project in Xcode
2. Select project in navigator
3. Go to Package Dependencies
4. Remove:
   - supabase-swift
   - All related dependencies

**Verify**:
```bash
# Check Package.resolved
cat InfiniteStories/InfiniteStories.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
# Should not contain any Supabase packages
```

#### 4.5 Delete Supabase Files

**Files to Delete**:
```bash
rm InfiniteStories/Services/SupabaseService.swift
rm InfiniteStories/Services/SupabaseAIService.swift
rm InfiniteStories/Services/SupabaseConfig.swift
rm InfiniteStories/Services/SupabaseHelpers.swift
```

**Verify No Imports**:
```bash
grep -r "import Supabase" InfiniteStories/
# Should return no results
```

---

### Phase 5: Testing & Validation (Week 5)

#### 5.1 Unit Tests

**Create/Update Test Files**:

```swift
// Tests/FirebaseDataServiceTests.swift
import XCTest
@testable import InfiniteStories

class FirebaseDataServiceTests: XCTestCase {
    var sut: FirebaseDataService!

    override func setUp() {
        super.setUp()
        // Use Firebase emulator for testing
        sut = FirebaseDataService()
    }

    func testSaveHero() async throws {
        let hero = Hero.mockHero
        try await sut.saveHero(hero)

        let fetchedHeroes = try await sut.fetchHeroes()
        XCTAssertTrue(fetchedHeroes.contains(where: { $0.id == hero.id }))
    }

    func testFetchHeroesOrdering() async throws {
        // Test that heroes are returned in correct order
    }

    func testDeleteHero() async throws {
        // Test hero deletion
    }

    // Similar tests for stories, custom events
}

// Tests/FirebaseStorageServiceTests.swift
class FirebaseStorageServiceTests: XCTestCase {
    func testUploadAvatar() async throws {
        // Test avatar upload
    }

    func testDownloadAvatar() async throws {
        // Test avatar download
    }

    // Similar tests for audio and illustrations
}

// Tests/FirebaseAuthServiceTests.swift
class FirebaseAuthServiceTests: XCTestCase {
    func testSignUp() async throws {
        // Test user sign up
    }

    func testSignIn() async throws {
        // Test user sign in
    }

    func testSignOut() throws {
        // Test sign out
    }
}
```

**Run Tests**:
```bash
xcodebuild test \
  -project InfiniteStories/InfiniteStories.xcodeproj \
  -scheme InfiniteStories \
  -destination 'platform=iOS Simulator,name=iPhone 15'
```

**Target**: >80% code coverage for new Firebase services

#### 5.2 Integration Tests

**Test Scenarios**:

1. **End-to-End Story Creation Flow**
   - Create hero → Upload avatar → Generate story → Generate audio → Generate illustrations
   - Verify all data persisted correctly
   - Verify all storage files uploaded

2. **Authentication Flow**
   - Sign up → Sign in → Access protected resources → Sign out
   - Verify security rules enforced
   - Verify unauthorized access blocked

3. **Data Persistence**
   - Create data → Kill app → Relaunch → Verify data loaded
   - Test offline scenarios with Firestore cache

4. **Error Handling**
   - Network errors
   - Authentication errors
   - Invalid data errors
   - Storage errors

#### 5.3 Performance Testing

**Metrics to Measure**:

| Operation | Target | Current (Supabase) | Actual (Firebase) |
|-----------|--------|-------------------|-------------------|
| Fetch Heroes | <500ms | TBD | TBD |
| Fetch Stories | <500ms | TBD | TBD |
| Upload Avatar (1MB) | <2s | TBD | TBD |
| Generate Story | <10s | TBD | TBD |
| Generate Audio | <5s | TBD | TBD |

**Tools**:
- Xcode Instruments (Time Profiler, Network)
- Firebase Performance Monitoring SDK
- Custom analytics events

#### 5.4 Security Validation

**Security Rules Testing** (`backend/firestore.test.rules.ts`):

```typescript
import { assertFails, assertSucceeds } from '@firebase/rules-unit-testing';

describe('Firestore Security Rules', () => {
  it('should allow users to read their own heroes', async () => {
    const db = getFirestore('user123');
    await assertSucceeds(
      db.collection('heroes')
        .where('userId', '==', 'user123')
        .get()
    );
  });

  it('should deny users from reading other users heroes', async () => {
    const db = getFirestore('user123');
    await assertFails(
      db.collection('heroes')
        .where('userId', '==', 'user456')
        .get()
    );
  });

  it('should deny unauthenticated access', async () => {
    const db = getFirestore(null);
    await assertFails(
      db.collection('heroes').get()
    );
  });

  // Similar tests for stories, custom events, storage
});
```

**Run Security Tests**:
```bash
cd backend
npm run test:rules
```

#### 5.5 User Acceptance Testing

**Test Plan**:

1. **Hero Management**
   - [ ] Create hero
   - [ ] Edit hero
   - [ ] Delete hero
   - [ ] Upload avatar
   - [ ] View hero list

2. **Story Generation**
   - [ ] Generate story for hero
   - [ ] Generate audio
   - [ ] Generate illustrations
   - [ ] Play story audio
   - [ ] View illustrations

3. **Authentication**
   - [ ] Sign up new account
   - [ ] Sign in existing account
   - [ ] Sign out
   - [ ] Password reset (if implemented)

4. **Data Persistence**
   - [ ] Data survives app restart
   - [ ] Offline access to cached data
   - [ ] Sync when back online

**Beta Testing**:
- Recruit 5-10 internal testers
- Use TestFlight for distribution
- Collect feedback via form
- Fix critical bugs before production

---

### Phase 6: Production Deployment (Week 6)

#### 6.1 Pre-Deployment Checklist

**Backend**:
- [ ] All Cloud Functions deployed to production
- [ ] Firestore security rules deployed
- [ ] Storage security rules deployed
- [ ] Composite indexes created
- [ ] OpenAI API key configured
- [ ] Cost monitoring alerts configured
- [ ] Performance monitoring enabled
- [ ] Error reporting configured

**iOS App**:
- [ ] All tests passing
- [ ] No Supabase imports remaining
- [ ] Firebase Analytics integrated
- [ ] Firebase Crashlytics integrated
- [ ] App version bumped
- [ ] Build number incremented
- [ ] GoogleService-Info.plist for production

**Documentation**:
- [ ] CHANGELOG updated
- [ ] README updated
- [ ] API documentation updated
- [ ] Migration notes documented

#### 6.2 Deployment Steps

**Backend Deployment**:
```bash
cd backend

# Deploy to production
firebase use infinite-stories-prod

# Deploy all services
firebase deploy --only firestore:rules
firebase deploy --only firestore:indexes
firebase deploy --only storage
firebase deploy --only functions

# Verify deployment
firebase functions:list
firebase firestore:indexes
```

**iOS Deployment**:
```bash
# 1. Update version
# Edit Info.plist: CFBundleShortVersionString = "2.0.0"
# Edit Info.plist: CFBundleVersion = "1"

# 2. Build for release
xcodebuild clean build \
  -project InfiniteStories/InfiniteStories.xcodeproj \
  -scheme InfiniteStories \
  -configuration Release

# 3. Archive
xcodebuild archive \
  -project InfiniteStories/InfiniteStories.xcodeproj \
  -scheme InfiniteStories \
  -archivePath build/InfiniteStories.xcarchive

# 4. Upload to App Store Connect
# Use Xcode Organizer or xcodebuild -exportArchive
```

#### 6.3 Rollout Strategy

**Phased Rollout**:

1. **Internal Testing (Day 1)**
   - Deploy to TestFlight for internal team
   - Monitor for critical issues
   - Duration: 24 hours

2. **Beta Testing (Days 2-3)**
   - Release to external beta testers
   - Monitor crash rates and feedback
   - Fix any critical bugs
   - Duration: 48 hours

3. **Gradual Rollout (Days 4-7)**
   - Release to 10% of users (Day 4)
   - Increase to 25% of users (Day 5)
   - Increase to 50% of users (Day 6)
   - Release to 100% of users (Day 7)

**Monitoring During Rollout**:
- Crash-free rate: >99.5%
- ANR (Application Not Responding) rate: <0.1%
- API error rate: <1%
- User retention: maintain or improve

#### 6.4 Rollback Plan

**Immediate Rollback Triggers**:
- Crash rate >1%
- Critical functionality broken (can't create heroes/stories)
- Data loss detected
- Authentication failures >5%
- Cloud Functions failure rate >10%

**Rollback Procedure**:

1. **iOS App Rollback**:
   ```bash
   # In App Store Connect:
   # - Pause phased release
   # - Promote previous version
   # - Submit for expedited review if needed
   ```

2. **Backend Rollback**:
   ```bash
   # Revert Cloud Functions
   firebase rollback functions:storyGeneration

   # Revert Firestore rules
   firebase deploy --only firestore:rules # with old rules
   ```

3. **Communication**:
   - Update status page
   - Email affected users
   - Post in support channels

#### 6.5 Post-Deployment Monitoring (First 7 Days)

**Daily Checks**:
- [ ] Review Firebase Crashlytics reports
- [ ] Review Cloud Functions logs for errors
- [ ] Check Firebase Performance metrics
- [ ] Monitor Cloud Functions costs
- [ ] Review user feedback
- [ ] Check support tickets

**Key Metrics Dashboard**:
```
Daily Active Users (DAU): ___
Stories Generated: ___
Average Response Time: ___
Error Rate: ___
Cost per Day: ___
User Satisfaction: ___
```

---

## Data Migration Strategy (If Production Data Exists)

### Pre-Migration

1. **Backup Supabase Data**
   ```bash
   # Backup PostgreSQL database
   pg_dump -h db.your-project.supabase.co -U postgres > supabase_backup.sql

   # Backup Storage
   # Use Supabase CLI or manual download
   ```

2. **Verify Data Integrity**
   - Count records in each table
   - Verify storage file counts
   - Document any data anomalies

3. **Create Migration Scripts**
   - See Phase 3.2 implementation
   - Test on staging data first

### Migration Execution

1. **Read-Only Mode** (Optional)
   - Put Supabase in read-only mode if possible
   - Prevent new writes during migration

2. **Run Migration**
   ```bash
   npm run migrate:heroes
   npm run migrate:stories
   npm run migrate:storage
   ```

3. **Validation**
   - Compare record counts
   - Spot-check random records
   - Verify storage URLs accessible

### Post-Migration

1. **Dual-Write Period** (Optional)
   - Write to both Supabase and Firebase
   - Compare results for consistency
   - Duration: 1 week

2. **Gradual Cutover**
   - Switch read traffic to Firebase incrementally
   - Monitor for issues
   - Keep Supabase as fallback

3. **Decommission Supabase**
   - After 30 days of stable Firebase operation
   - Archive final backup
   - Cancel Supabase subscription

---

## Risk Assessment & Mitigation

### Critical Risks

#### Risk 1: Data Loss During Migration
**Impact**: Critical
**Probability**: Low
**Mitigation**:
- Comprehensive backup strategy before migration
- Test migration scripts thoroughly on staging data
- Validate data after migration with automated scripts
- Keep Supabase backup for 90 days
- Implement dual-write if production data exists

#### Risk 2: Authentication Disruption
**Impact**: High
**Probability**: Medium
**Mitigation**:
- Implement gradual user migration
- Provide clear user communication
- Support password reset flow
- Maintain session compatibility during transition
- Test authentication flows extensively

#### Risk 3: Performance Degradation
**Impact**: High
**Probability**: Medium
**Mitigation**:
- Benchmark Firebase performance early in development
- Optimize Firestore queries and indexes
- Implement caching strategies
- Use Firebase Performance Monitoring
- Load test before production deployment

#### Risk 4: Cost Overrun
**Impact**: Medium
**Probability**: Medium
**Mitigation**:
- Set up Firebase billing alerts
- Implement rate limiting in Cloud Functions
- Optimize function cold starts
- Use minimum instances for critical functions
- Monitor costs daily during first month

### Medium Risks

#### Risk 5: Feature Parity Issues
**Impact**: Medium
**Probability**: Medium
**Mitigation**:
- Comprehensive testing of all features
- User acceptance testing with beta group
- Maintain feature checklist
- Compare feature behavior with Supabase implementation

#### Risk 6: Development Delays
**Impact**: Medium
**Probability**: Medium
**Mitigation**:
- Buffer time in schedule (6 weeks with flexibility)
- Parallel development tracks where possible
- Clear milestone tracking with PRD tool
- Regular progress reviews

### Low Risks

#### Risk 7: Storage URL Changes
**Impact**: Low
**Probability**: High
**Mitigation**:
- Update URLs in database during migration
- Implement URL migration logic in app
- Test all media loading thoroughly

---

## Testing Strategy

### Unit Testing

**Coverage Target**: >80% for new Firebase services

**Files**:
- `FirebaseDataService` - All CRUD operations
- `FirebaseStorageService` - All upload/download operations
- `FirebaseAuthService` - All authentication flows
- `FirebaseAIService` - All Cloud Function calls

**Setup**:
```bash
# Use Firebase Emulator Suite for testing
firebase emulators:start --only auth,firestore,storage,functions

# In tests
XCTestCase.setUp() {
    // Point to emulators
    Auth.auth().useEmulator(withHost: "localhost", port: 9099)
    let settings = Firestore.firestore().settings
    settings.host = "localhost:8080"
    settings.isSSLEnabled = false
}
```

### Integration Testing

**Scenarios**:
1. Full story creation flow (E2E)
2. Authentication flow
3. Offline data access
4. Error handling
5. Storage operations

**Tools**:
- XCTest framework
- Firebase Test Lab (optional)
- Manual testing on physical devices

### Performance Testing

**Benchmarks**:
- Firestore query latency
- Storage upload/download speed
- Cloud Function response time
- App launch time
- Memory usage

**Tools**:
- Xcode Instruments
- Firebase Performance Monitoring
- Custom analytics events

### Security Testing

**Areas**:
- Firestore security rules
- Storage security rules
- Authentication flows
- API endpoint protection

**Tools**:
- Firebase Security Rules Unit Testing
- Manual penetration testing
- Automated security scans

---

## Success Metrics

### Technical Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Migration Completion | 100% features | Feature checklist |
| Data Integrity | 0% data loss | Automated validation |
| Performance | <10% latency increase | Firebase Performance Monitoring |
| Availability | 99.9% uptime | Firebase Status Dashboard |
| Error Rate | <1% increase | Firebase Crashlytics |
| Test Coverage | >80% | Xcode coverage report |

### Business Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| User Retention | >95% | Firebase Analytics |
| User Satisfaction | NPS maintained or improved | In-app survey |
| Cost Efficiency | <20% cost increase | Firebase Billing Dashboard |
| Feature Adoption | No decline | Firebase Analytics events |
| Support Tickets | <50% increase | Support system |

### Operational Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Deployment Success | 100% | CI/CD logs |
| Rollback Readiness | <15 min rollback time | Rollback drills |
| Monitoring Coverage | 100% critical paths | Firebase Monitoring setup |
| Documentation | 100% changes documented | Documentation review |
| Team Knowledge | 100% team trained | Training completion |

---

## Timeline & Milestones

### Week 1: Foundation & Setup
- [ ] Day 1-2: Firestore security rules & indexes deployed
- [ ] Day 3-4: Storage security rules deployed
- [ ] Day 5: Backend verification complete
- [ ] Milestone: Backend infrastructure ready

### Week 2: Service Implementation
- [ ] Day 1-2: FirebaseDataService implemented
- [ ] Day 2-3: FirebaseStorageService implemented
- [ ] Day 4: FirebaseAuthService integrated
- [ ] Day 5: AIServiceFactory updated
- [ ] Milestone: All Firebase services implemented

### Week 3: Model Updates & Migration
- [ ] Day 1-2: Model Codable updates complete
- [ ] Day 3-4: Data migration script created and tested
- [ ] Day 5: Migration dry-run successful
- [ ] Milestone: Data migration ready

### Week 4: iOS Integration
- [ ] Day 1-2: ViewModels updated
- [ ] Day 2-3: Views updated
- [ ] Day 4: Supabase dependencies removed
- [ ] Day 5: Supabase files deleted
- [ ] Milestone: iOS app fully on Firebase

### Week 5: Testing & Validation
- [ ] Day 1-2: Unit tests complete
- [ ] Day 2-3: Integration tests complete
- [ ] Day 3-4: Performance tests complete
- [ ] Day 4-5: Security validation complete
- [ ] Day 5: User acceptance testing
- [ ] Milestone: All tests passing

### Week 6: Production Deployment
- [ ] Day 1: Pre-deployment checklist complete
- [ ] Day 2: Backend deployed to production
- [ ] Day 3: iOS app submitted to App Store
- [ ] Day 4-7: Phased rollout to users
- [ ] Milestone: Production deployment successful

---

## Acceptance Criteria

### Must Have (Blocking)

- [ ] **Zero Supabase Code**: No imports, no references, no dependencies
- [ ] **Feature Parity**: All existing features work identically
- [ ] **Data Migration**: All production data migrated successfully (if applicable)
- [ ] **Authentication**: All users can authenticate and access their data
- [ ] **Tests Passing**: >80% coverage, all critical paths tested
- [ ] **Security**: All security rules deployed and validated
- [ ] **Performance**: No more than 10% latency increase
- [ ] **Documentation**: All changes documented

### Should Have (Important)

- [ ] **Offline Support**: Firestore cache working correctly
- [ ] **Error Handling**: All error cases handled gracefully
- [ ] **Analytics**: Firebase Analytics integrated
- [ ] **Crashlytics**: Firebase Crashlytics integrated
- [ ] **Monitoring**: Performance monitoring active
- [ ] **Cost Alerts**: Billing alerts configured

### Could Have (Nice to Have)

- [ ] **Real-time Updates**: Firestore listeners for live data
- [ ] **Advanced Analytics**: Custom events for user behavior
- [ ] **Remote Config**: Feature flags via Firebase Remote Config
- [ ] **A/B Testing**: Firebase A/B Testing setup

---

## Post-Migration Tasks

### Immediate (Week 7)

- [ ] Monitor system health daily
- [ ] Address critical issues within 24 hours
- [ ] Gather user feedback via in-app survey
- [ ] Performance optimization based on metrics
- [ ] Update documentation with lessons learned

### Short-term (Month 2)

- [ ] Decommission Supabase infrastructure
- [ ] Cost optimization review
- [ ] Feature enhancements planning
- [ ] Architecture improvements
- [ ] Team retrospective

### Long-term (Month 3+)

- [ ] Advanced Firebase features adoption (Remote Config, A/B Testing)
- [ ] Scaling strategies implementation
- [ ] Platform expansion planning
- [ ] Team training on advanced Firebase features
- [ ] Architecture evolution

---

## Dependencies & Assumptions

### Dependencies

**Technical**:
- Firebase project created and configured
- OpenAI API access maintained
- iOS development environment setup
- Backend deployment infrastructure ready

**Team**:
- iOS developer available full-time
- Backend developer for Cloud Functions support
- QA resources for testing
- DevOps for deployment support

**External**:
- Firebase service availability
- OpenAI API availability
- App Store review process

### Assumptions

- No new features added during migration period
- Production data volume is manageable for migration
- Users willing to re-authenticate if needed
- Firebase pricing remains competitive
- Team has sufficient Firebase expertise or learning time

---

## Communication Plan

### Stakeholders

**Internal**:
- Development team: Daily updates
- Product team: Weekly progress reports
- Management: Bi-weekly status reviews

**External**:
- Users: In-app notifications for updates
- Beta testers: Email updates for TestFlight builds
- Support team: Migration FAQ and troubleshooting guide

### Channels

- **Slack**: #infinite-stories-migration for daily updates
- **Email**: Weekly progress reports
- **Status Page**: Public status updates during deployment
- **In-App**: Notifications for users about updates

---

## Rollback Plan

### Immediate Rollback (0-24 hours)

**Triggers**:
- Critical bug affecting >10% users
- Data corruption detected
- Authentication failures >5%
- Performance degradation >50%
- Cloud Functions failure rate >10%

**Procedure**:
1. Pause App Store release
2. Revert to previous app version if possible
3. Switch Cloud Functions to maintenance mode
4. Communicate issue to users
5. Begin root cause analysis

### Gradual Rollback (Day 2-7)

**Triggers**:
- Persistent minor issues
- User satisfaction decline
- Cost significantly over budget
- Feature gaps identified

**Procedure**:
1. Maintain dual backend operation (if possible)
2. Fix issues in Firebase
3. Gradual user migration back if needed
4. Re-plan migration strategy

---

## Conclusion

This PRD provides a comprehensive roadmap for completely removing Supabase from InfiniteStories iOS app and migrating to Firebase. The migration is critical for:

1. **Simplification**: Single backend platform
2. **Cost Optimization**: Better pricing for our use case
3. **Developer Experience**: Superior iOS SDK integration
4. **Feature Velocity**: Faster development with Firebase tools

**Success depends on**:
- Thorough testing at each phase
- Careful data migration
- Comprehensive monitoring
- Ability to rollback if needed

**Next Steps**:
1. Review and approve this PRD
2. ✅ **PRD task tracking tool is ready** - Use the enhanced PRD tool to track all tasks
3. Assign owners to each phase using agent system
4. Begin Phase 1 implementation

### Using the PRD Tool for This Migration

All tasks from this PRD are already loaded into the PRD tool with:
- **Human-readable IDs**: Tasks #1-#88, Agents A1-A5
- **Epic grouping**: Tasks organized by migration phases
- **Dependencies**: Task ordering defined
- **Acceptance criteria**: Definition of done for each task
- **Agent coordination**: 5 specialized agents ready

**Quick commands to get started:**

```bash
# View migration overview
prd show "#1"  # Complete Supabase to Firebase Migration

# See all phases
prd list | grep "Phase"

# View specific phase breakdown
prd show "#2"  # Phase 1: Foundation & Setup

# Check what's ready to work on
prd ready

# Assign work to agents
prd sync ios-engineer-agent "#task"
prd sync firebase-backend-agent "#task"

# Track epic progress
prd epics

# View overall progress
prd stats  # Shows 11.4% complete (10/88 tasks)
```

**Example workflow:**

```bash
# 1. Review Phase 1 tasks
prd show "#2"  # Phase 1 parent task

# 2. Add acceptance criteria
prd ac "#3" add "Security rules deployed"
prd ac "#3" add "Indexes created"
prd ac "#3" add "All tests pass"

# 3. Set dependencies
prd depends "#4" --on "#3"  # StorageServiceProtocol depends on DataServiceProtocol

# 4. Start working
prd sync A2 "#3"  # Firebase backend agent takes DataServiceProtocol task

# 5. Track progress
prd ac "#3" check 1  # Mark criteria complete
prd update "#3" completed

# 6. View epic progress
prd epics  # See Phase 1 progress
```

---

## Appendix

### A. Files Inventory

**Files to Create**:
```
InfiniteStories/Services/Protocols/DataServiceProtocol.swift
InfiniteStories/Services/Protocols/StorageServiceProtocol.swift
InfiniteStories/Services/Protocols/AuthServiceProtocol.swift
InfiniteStories/Services/FirebaseDataService.swift
InfiniteStories/Services/FirebaseStorageService.swift
InfiniteStories/Services/FirebaseAuthService.swift (move from Firebase-Pending)
InfiniteStories/Views/Auth/FirebaseAuthView.swift (move from Firebase-Pending)
Tests/FirebaseDataServiceTests.swift
Tests/FirebaseStorageServiceTests.swift
Tests/FirebaseAuthServiceTests.swift
backend/scripts/migrate-data.ts
backend/firestore.test.rules.ts
```

**Files to Modify**:
```
InfiniteStories/InfiniteStoriesApp.swift
InfiniteStories/Services/AIServiceFactory.swift
InfiniteStories/Services/FirebaseConfig.swift
InfiniteStories/Services/FirebaseAIService.swift
InfiniteStories/Models/Hero.swift
InfiniteStories/Models/Story.swift
InfiniteStories/Models/CustomStoryEvent.swift
InfiniteStories/ViewModels/HeroViewModel.swift
InfiniteStories/ViewModels/StoryViewModel.swift
InfiniteStories.xcodeproj/project.pbxproj
backend/firestore.rules
backend/firestore.indexes.json
backend/storage.rules
```

**Files to Delete**:
```
InfiniteStories/Services/SupabaseService.swift
InfiniteStories/Services/SupabaseAIService.swift
InfiniteStories/Services/SupabaseConfig.swift
InfiniteStories/Services/SupabaseHelpers.swift
```

### B. Command Reference

```bash
# Backend Deployment
firebase deploy --only firestore:rules
firebase deploy --only firestore:indexes
firebase deploy --only storage
firebase deploy --only functions
firebase functions:secrets:set OPENAI_API_KEY

# Testing
xcodebuild test -project InfiniteStories/InfiniteStories.xcodeproj \
  -scheme InfiniteStories \
  -destination 'platform=iOS Simulator,name=iPhone 15'

npm run test:rules  # Firestore rules testing

# Build & Archive
xcodebuild archive \
  -project InfiniteStories/InfiniteStories.xcodeproj \
  -scheme InfiniteStories \
  -archivePath build/InfiniteStories.xcarchive

# Monitoring
firebase functions:log --only storyGeneration
firebase firestore:indexes
```

### C. Security Rules Reference

See Phase 1.3 for complete Firestore rules
See Phase 1.4 for complete Storage rules

### D. Cost Estimation

**Firebase Pricing** (Monthly estimates):

| Service | Free Tier | Expected Usage | Estimated Cost |
|---------|-----------|----------------|----------------|
| Firestore | 50K reads, 20K writes | 100K reads, 50K writes | $0.36 |
| Storage | 5GB, 1GB downloads | 10GB, 5GB downloads | $0.25 |
| Cloud Functions | 2M invocations | 500K invocations | $0 (free tier) |
| Authentication | Unlimited | 1K users | $0 |
| **Total** | | | **~$1/month** |

**Notes**:
- OpenAI costs separate and unchanged
- Costs scale with user growth
- Set billing alerts at $10, $50, $100

---

**Document Status**: Draft v1.0
**Next Review**: After team approval
**Implementation Start**: TBD after approval
